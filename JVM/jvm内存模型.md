



## 1. 程序计数器

<img src="C:\Users\大梦\AppData\Roaming\Typora\typora-user-images\image-20210722165115748.png" alt="image-20210722165115748" style="zoom: 80%;" />

### 1.1.定义

**作用**

​		记录下一次执行的jvm指令的执行地址

**特点**

> 是线程安全的
>
> 不会存在内存溢出

## 2. 虚拟机栈

<img src="C:\Users\大梦\AppData\Roaming\Typora\typora-user-images\image-20210722165155852.png" alt="image-20210722165155852" style="zoom: 80%;" />

### 2.1 定义

给每个线程分配的内存空间，其内存结构是栈结构，先进后出。

基本单位是方法帧，每次执行方法，就在栈中分配内存给方法帧。执行完方法就直接出栈

#### 2.1.1 问题辨析

1.垃圾回收是否涉及到栈内存？

> 不涉及到栈内存，栈中直接自己出栈

2.栈的内存分配越大越好吗？？

> 不是，默认分配是1m。当栈的内存大了，其线程数就会减少。所以不是越大越好

3.方法区的局部变量是否是线程安全

> 如果局部变量没有逃离方法的作用访问，是线程安全的
>
> 如果局部变量引用了对象，并逃离了方法的作用范围，那么是线程不安全的

### 2.2 栈内存溢出

栈帧过多导致的栈内存溢出

栈帧过大导致的栈内存溢出

### 2.3 线程运行诊断

**定位**

> 1. 用top定位哪个进程对cpu的占用过高
> 2. ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
> 3. jstack 进程id
>    			可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号

## 3. 本地方法栈

<img src="C:\Users\大梦\AppData\Roaming\Typora\typora-user-images\image-20210722170806902.png" alt="image-20210722170806902" style="zoom: 80%;" />

### 3.1 定义

给本地方法的运行提供存储空间

## 4. 堆

<img src="C:\Users\大梦\AppData\Roaming\Typora\typora-user-images\image-20210722171329291.png" alt="image-20210722171329291" style="zoom: 80%;" />

### 4.1 定义

**heap堆**

> 通过关键字，**创建对象都会使用堆内存**

**特点**

* 是线程共享的堆中的对象需要考虑线程安全问题
* 有垃圾回收机制

### 4.2 堆内存诊断

1. jps 工具
   查看当前系统中有哪些 java 进程

2. jmap 工具
   查看堆内存占用情况 jmap - heap 进程id

3. **jconsole 工具**
   **图形界面的，多功能的监测工具，可以连续监测**

## 5.方法区

<img src="C:\Users\大梦\AppData\Roaming\Typora\typora-user-images\image-20210722175257519.png" alt="image-20210722175257519" style="zoom: 80%;" />

### 5.1 定义

<img src="C:\Users\大梦\AppData\Roaming\Typora\typora-user-images\image-20210722213016361.png" alt="image-20210722213016361" style="zoom:67%;" />

### 5.2 方法区内存溢出

会导致元空间内存溢出

### 5.3 运行时常量池

* 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息

* 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

### 5.4 StringTable

* 常量池中的字符串仅是符号，第一次用到时才变为对象

* 利用串池的机制，来避免重复创建字符串对象

* 字符串变量拼接的原理是 StringBuilder （1.8）

* 字符串常量拼接的原理是编译期优化

* 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池

  * 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回

  * 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，
    放入串池， 会把串池中的对象返回

    

### 5.5StringTable 性能调优

在stringtable的存储中其是使用hashtable存储的。可以通过增加其桶的个数来增加性能

**调整 -XX:StringTableSize=桶个数**